package main

import (
	"bufio"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"strconv"
	"strings"
)

// use for map and mapb commands
type LocationAreaResponse struct {
	Count    int            `json:"count"`
	Next     string         `json:"next"`
	Previous interface{}    `json:"previous"` // Use interface{} to handle null values
	Results  []LocationArea `json:"results"`
}

type LocationArea struct {
	Name string `json:"name"`
	URL  string `json:"url"`
}

func mapLocationAreaParse(data []byte) {
	var response LocationAreaResponse
	err := json.Unmarshal([]byte(data), &response)
	if err != nil {
		fmt.Println("Error:", err)
		return
	}

	/* DEBUG
	fmt.Println("Count:", response.Count)
	fmt.Println("Next:", response.Next)
	fmt.Println("Previous:", response.Previous)
	fmt.Println("Results:", response.Results)
	*/

	for _, result := range response.Results {
		fmt.Println(result.Name)
	}

}

func main() {
	currentMapOffset := -20
	baseURL := "https://pokeapi.co/api/v2"
	// define commands and their actions - start
	commands := map[string]func(){
		"help": func() {
			fmt.Print(`
Welcome to the Pokedex!
Usage:
  help : Displays a help message
  exit : Exit the Pokedex
  map  : Displays the names of 20 location areas in the Pokemon world.
		 Each subsequent call to map should display the next 20 
		 locations, and so on.
  mapb : Similar to the map command, however, instead of displaying 
  		 the next 20 locations, it displays the previous 20 locations. 
		 It's a way to go back. If you're on the first "page" of 
		 results, this command will print an error.
`)
		},

		// Exit the program
		"exit": func() {
			fmt.Println("Exiting the Pokedex. Goodbye!")
			os.Exit(0) // Exit the program
		},

		//The map command displays the names of 20 location areas in the Pokemon world.
		//Each subsequent call to map should display the next 20 locations, and so on.
		//The idea is that the map command will let us explore the world of Pokemon.
		"map": func() {
			//GET https://pokeapi.co/api/v2/location-area/{id or name}/
			//eg. https://pokeapi.co/api/v2/location-area?offset=0&limit=20
			currentMapOffset += 20
			locationAreaOffset := currentMapOffset
			locationAreaLimit := "20"
			locationAreaURL := baseURL + "/location-area?offset=" + strconv.Itoa(locationAreaOffset) + "&limit=" + locationAreaLimit
			//fmt.Printf("DEBUG map url:" + locationAreaURL + "\n")

			res, err := http.Get(locationAreaURL)
			if err != nil {
				log.Fatal(err)
			}
			body, err := io.ReadAll(res.Body)
			res.Body.Close()
			if res.StatusCode > 299 {
				log.Fatalf("Response failed with status code: %d and\nbody: %s\n", res.StatusCode, body)
			}
			if err != nil {
				log.Fatal(err)
			}
			//fmt.Printf("%s\n\n", body)
			mapLocationAreaParse(body)

		},

		//Similar to the map command, however, instead of displaying the next 20
		//locations, it displays the previous 20 locations. It's a way to go back.
		//If you're on the first "page" of results, this command should just print an
		//error message.
		"mapb": func() {
			currentMapOffset -= 20
			locationAreaOffset := 0
			if currentMapOffset < 0 {
				currentMapOffset = -20
				fmt.Printf("can't go back anymore... \n")
			} else {
				locationAreaOffset = currentMapOffset
				locationAreaLimit := "20"
				locationAreaURL := baseURL + "/location-area?offset=" + strconv.Itoa(locationAreaOffset) + "&limit=" + locationAreaLimit
				//fmt.Printf("DEBUG mapb url:" + locationAreaURL + "\n")

				res, err := http.Get(locationAreaURL)
				if err != nil {
					log.Fatal(err)
				}
				body, err := io.ReadAll(res.Body)
				res.Body.Close()
				if res.StatusCode > 299 {
					log.Fatalf("Response failed with status code: %d and\nbody: %s\n", res.StatusCode, body)
				}
				if err != nil {
					log.Fatal(err)
				}
				//fmt.Printf("%s\n\n", body)
				mapLocationAreaParse(body)
			}
		},
	} // define commands and their actions - end

	reader := bufio.NewReader(os.Stdin)
	for {
		fmt.Print("Pokedex > ")
		text, _ := reader.ReadString('\n')
		command := strings.TrimSpace(text)

		// Execute the command if it exists in the map
		if action, exists := commands[command]; exists {
			action()
		} else {
			fmt.Println("Unknown command. Type 'help' for a list of commands.\n")
		}
	}

}
